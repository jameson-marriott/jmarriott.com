---
title: "How many rounds of Tenzi does it take to win?"
slug: "tenzi"
author: "Jameson Marriott"
date: "2019-01-02"
output:
  blogdown::html_page:
    toc: true
    fig_width: 6
    dev: "svg"
draft: TRUE
---



<p>I spent some time over Christmas playing games of chance with my in-laws. Some of them didn’t have any strategy at all, and they left me wondering what the odds were of wining. In the case of Tenzi, the only thing you can really do to get better at the game is to roll and read dice faster. If you’re not familiar with the rules, you can find them <a href="https://ilovetenzi.com/rules/">here</a>.</p>
<p>Let’s start by looking at how many rolls it takes to win. We’ll be using r, and this post assumes some familiarity with that language. Frst we’ll load the tidyverse.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<p>There is probably a straightforward way to mathematically solve this problem, but it will be quite easy to simulate, so that’s the approach I’m going take. I’ll start by simulating a roll of ten dice, chose the most comon number to keep rolling, and then roll the diminishing dice until they all have the same result.</p>
<pre class="r"><code># Roll ten dice, get the count of the number with the most rolls
dice_rolls &lt;- data_frame(roll = sample(1:6, 10, replace = TRUE)) %&gt;%
  group_by(roll) %&gt;%
  summarize(count = n()) %&gt;%
  arrange(desc(count))

# Record the chosen number
roll_int &lt;- as.integer(dice_rolls[1, 1])

# Record the number of dice rolled with the chosen number
count_int &lt;- as.integer(dice_rolls[1,2])

# Count the number of times a hand of dice is rolled
roll_count_int &lt;- as.integer(0)

while(count_int &lt; 10) {
  count_int = count_int + data_frame(roll = sample(1:6, 10 - count_int, replace = TRUE)) %&gt;%
    filter(roll == roll_int) %&gt;%
    length()
  roll_count_int = roll_count_int + 1
}</code></pre>
<p>On this particular simulated series of rolls, it took 6 rolls to achieve ten dice with the number 4.</p>
<p>Let’s turn this code into a function that we can call over and over again to create some data we can look at to figure out how many rolls it usually takes to win.</p>
<pre class="r"><code>round_of_tenzi &lt;- function() {
  # Roll ten dice, get the count of the number with the most rolls
  dice_rolls &lt;- data_frame(roll = sample(1:6, 10, replace = TRUE)) %&gt;%
  group_by(roll) %&gt;%
  summarize(count = n()) %&gt;%
  arrange(desc(count))
  
  # Record the chosen number
  roll_int &lt;- as.integer(dice_rolls[1, 1])
  
  # Record the number of dice rolled with the chosen number
  count_int &lt;- as.integer(dice_rolls[1,2])
  
  # Count the number of times a hand of dice is rolled
  roll_count_int &lt;- as.integer(0)
  while(count_int &lt; 10) {
    count_int = count_int + data_frame(roll = sample(1:6, 10 - count_int, replace = TRUE)) %&gt;%
      filter(roll == roll_int) %&gt;%
      length()
    roll_count_int = roll_count_int + 1
    }
  return(roll_count_int)
  }</code></pre>
<p>Now we’re ready to simulate rolling the dice a bunch of times. Just running the function a few times in the console, it looks like the average number of rolls that it takes to win will be somewhere from six to eight.</p>
<pre class="r"><code># Create a dataframe to store all the results in
rolls_df &lt;- data_frame(num_rolls = rep(0, 1e+06))

# Iterate through the dataframe, running a simulated instance of Tenzi for each row
for (i in 1:1e+06) {
  rolls_df[i,1] &lt;- round_of_tenzi()
}</code></pre>
<p>That took about four hours to compute on my laptop. That would probably be too long for a production environment, but for a one-time computation that’s OK. I started it before I went to bed and it was ready in the morning.</p>
<p>Now, let’s take a look at the data.</p>
<pre class="r"><code>rolls_df %&gt;%
  ggplot(aes(x = num_rolls)) +
  geom_histogram(binwidth = 1) +
  theme_bw() +
  ggtitle(&quot;Distribution of number of dice rolls in Tenzi&quot;)</code></pre>
<p><img src="/posts/2019-01-02-tenzi_files/figure-html/graph_data-1.svg" width="576" /></p>
<p>It’s interesting that the distribution drops off so sharply after seven rolls. Let’s see what the probablility is of winning for each number of rolls.</p>
<pre class="r"><code>rolls_df %&gt;%
  group_by(num_rolls) %&gt;%
  summarise(count = n()) %&gt;%
  mutate(percent = count/1e+04)</code></pre>
<pre><code>## # A tibble: 8 x 3
##   num_rolls  count   percent
##       &lt;int&gt;  &lt;int&gt;     &lt;dbl&gt;
## 1         1      3  0.000300
## 2         2    104  0.0104  
## 3         3   1444  0.144   
## 4         4  12942  1.29    
## 5         5  77944  7.79    
## 6         6 310952 31.1     
## 7         7 529072 52.9     
## 8         8  67539  6.75</code></pre>
<p>So, the person who gets all their dice in four-five rolls is likely the winner. And, if you’ve rolled ten times then you probably missed a dice and re-rolled it by accident.</p>
<p>I’m sure that there’s a more efficient way to simulate this problem. Maybe in a future post I’ll look into running my function in parallel which would reduce the runtime considerably. Also, it would be interesting to see the distrubution of the number of dice rolled each round. In other words, how often does a player have to roll only one dice two-three times before ending the round.</p>
<p>Comment belown on what improvements you see to this short excercise!</p>
